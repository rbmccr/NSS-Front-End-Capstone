(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*
 * heatmap.js v2.0.5 | JavaScript Heatmap Library
 *
 * Copyright 2008-2016 Patrick Wied <heatmapjs@patrick-wied.at> - All rights reserved.
 * Dual licensed under MIT and Beerware license 
 *
 * :: 2016-09-05 01:16
 */
;(function (name, context, factory) {

  // Supports UMD. AMD, CommonJS/Node.js and browser context
  if (typeof module !== "undefined" && module.exports) {
    module.exports = factory();
  } else if (typeof define === "function" && define.amd) {
    define(factory);
  } else {
    context[name] = factory();
  }

})("h337", this, function () {

// Heatmap Config stores default values and will be merged with instance config
var HeatmapConfig = {
  defaultRadius: 40,
  defaultRenderer: 'canvas2d',
  defaultGradient: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1.0: "rgb(255,0,0)"},
  defaultMaxOpacity: 1,
  defaultMinOpacity: 0,
  defaultBlur: .85,
  defaultXField: 'x',
  defaultYField: 'y',
  defaultValueField: 'value', 
  plugins: {}
};
var Store = (function StoreClosure() {

  var Store = function Store(config) {
    this._coordinator = {};
    this._data = [];
    this._radi = [];
    this._min = 10;
    this._max = 1;
    this._xField = config['xField'] || config.defaultXField;
    this._yField = config['yField'] || config.defaultYField;
    this._valueField = config['valueField'] || config.defaultValueField;

    if (config["radius"]) {
      this._cfgRadius = config["radius"];
    }
  };

  var defaultRadius = HeatmapConfig.defaultRadius;

  Store.prototype = {
    // when forceRender = false -> called from setData, omits renderall event
    _organiseData: function(dataPoint, forceRender) {
        var x = dataPoint[this._xField];
        var y = dataPoint[this._yField];
        var radi = this._radi;
        var store = this._data;
        var max = this._max;
        var min = this._min;
        var value = dataPoint[this._valueField] || 1;
        var radius = dataPoint.radius || this._cfgRadius || defaultRadius;

        if (!store[x]) {
          store[x] = [];
          radi[x] = [];
        }

        if (!store[x][y]) {
          store[x][y] = value;
          radi[x][y] = radius;
        } else {
          store[x][y] += value;
        }
        var storedVal = store[x][y];

        if (storedVal > max) {
          if (!forceRender) {
            this._max = storedVal;
          } else {
            this.setDataMax(storedVal);
          }
          return false;
        } else if (storedVal < min) {
          if (!forceRender) {
            this._min = storedVal;
          } else {
            this.setDataMin(storedVal);
          }
          return false;
        } else {
          return { 
            x: x, 
            y: y,
            value: value, 
            radius: radius,
            min: min,
            max: max 
          };
        }
    },
    _unOrganizeData: function() {
      var unorganizedData = [];
      var data = this._data;
      var radi = this._radi;

      for (var x in data) {
        for (var y in data[x]) {

          unorganizedData.push({
            x: x,
            y: y,
            radius: radi[x][y],
            value: data[x][y]
          });

        }
      }
      return {
        min: this._min,
        max: this._max,
        data: unorganizedData
      };
    },
    _onExtremaChange: function() {
      this._coordinator.emit('extremachange', {
        min: this._min,
        max: this._max
      });
    },
    addData: function() {
      if (arguments[0].length > 0) {
        var dataArr = arguments[0];
        var dataLen = dataArr.length;
        while (dataLen--) {
          this.addData.call(this, dataArr[dataLen]);
        }
      } else {
        // add to store  
        var organisedEntry = this._organiseData(arguments[0], true);
        if (organisedEntry) {
          // if it's the first datapoint initialize the extremas with it
          if (this._data.length === 0) {
            this._min = this._max = organisedEntry.value;
          }
          this._coordinator.emit('renderpartial', {
            min: this._min,
            max: this._max,
            data: [organisedEntry]
          });
        }
      }
      return this;
    },
    setData: function(data) {
      var dataPoints = data.data;
      var pointsLen = dataPoints.length;


      // reset data arrays
      this._data = [];
      this._radi = [];

      for(var i = 0; i < pointsLen; i++) {
        this._organiseData(dataPoints[i], false);
      }
      this._max = data.max;
      this._min = data.min || 0;
      
      this._onExtremaChange();
      this._coordinator.emit('renderall', this._getInternalData());
      return this;
    },
    removeData: function() {
      // TODO: implement
    },
    setDataMax: function(max) {
      this._max = max;
      this._onExtremaChange();
      this._coordinator.emit('renderall', this._getInternalData());
      return this;
    },
    setDataMin: function(min) {
      this._min = min;
      this._onExtremaChange();
      this._coordinator.emit('renderall', this._getInternalData());
      return this;
    },
    setCoordinator: function(coordinator) {
      this._coordinator = coordinator;
    },
    _getInternalData: function() {
      return { 
        max: this._max,
        min: this._min, 
        data: this._data,
        radi: this._radi 
      };
    },
    getData: function() {
      return this._unOrganizeData();
    }/*,

      TODO: rethink.

    getValueAt: function(point) {
      var value;
      var radius = 100;
      var x = point.x;
      var y = point.y;
      var data = this._data;

      if (data[x] && data[x][y]) {
        return data[x][y];
      } else {
        var values = [];
        // radial search for datapoints based on default radius
        for(var distance = 1; distance < radius; distance++) {
          var neighbors = distance * 2 +1;
          var startX = x - distance;
          var startY = y - distance;

          for(var i = 0; i < neighbors; i++) {
            for (var o = 0; o < neighbors; o++) {
              if ((i == 0 || i == neighbors-1) || (o == 0 || o == neighbors-1)) {
                if (data[startY+i] && data[startY+i][startX+o]) {
                  values.push(data[startY+i][startX+o]);
                }
              } else {
                continue;
              } 
            }
          }
        }
        if (values.length > 0) {
          return Math.max.apply(Math, values);
        }
      }
      return false;
    }*/
  };


  return Store;
})();

var Canvas2dRenderer = (function Canvas2dRendererClosure() {

  var _getColorPalette = function(config) {
    var gradientConfig = config.gradient || config.defaultGradient;
    var paletteCanvas = document.createElement('canvas');
    var paletteCtx = paletteCanvas.getContext('2d');

    paletteCanvas.width = 256;
    paletteCanvas.height = 1;

    var gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
    for (var key in gradientConfig) {
      gradient.addColorStop(key, gradientConfig[key]);
    }

    paletteCtx.fillStyle = gradient;
    paletteCtx.fillRect(0, 0, 256, 1);

    return paletteCtx.getImageData(0, 0, 256, 1).data;
  };

  var _getPointTemplate = function(radius, blurFactor) {
    var tplCanvas = document.createElement('canvas');
    var tplCtx = tplCanvas.getContext('2d');
    var x = radius;
    var y = radius;
    tplCanvas.width = tplCanvas.height = radius*2;

    if (blurFactor == 1) {
      tplCtx.beginPath();
      tplCtx.arc(x, y, radius, 0, 2 * Math.PI, false);
      tplCtx.fillStyle = 'rgba(0,0,0,1)';
      tplCtx.fill();
    } else {
      var gradient = tplCtx.createRadialGradient(x, y, radius*blurFactor, x, y, radius);
      gradient.addColorStop(0, 'rgba(0,0,0,1)');
      gradient.addColorStop(1, 'rgba(0,0,0,0)');
      tplCtx.fillStyle = gradient;
      tplCtx.fillRect(0, 0, 2*radius, 2*radius);
    }



    return tplCanvas;
  };

  var _prepareData = function(data) {
    var renderData = [];
    var min = data.min;
    var max = data.max;
    var radi = data.radi;
    var data = data.data;

    var xValues = Object.keys(data);
    var xValuesLen = xValues.length;

    while(xValuesLen--) {
      var xValue = xValues[xValuesLen];
      var yValues = Object.keys(data[xValue]);
      var yValuesLen = yValues.length;
      while(yValuesLen--) {
        var yValue = yValues[yValuesLen];
        var value = data[xValue][yValue];
        var radius = radi[xValue][yValue];
        renderData.push({
          x: xValue,
          y: yValue,
          value: value,
          radius: radius
        });
      }
    }

    return {
      min: min,
      max: max,
      data: renderData
    };
  };


  function Canvas2dRenderer(config) {
    var container = config.container;
    var shadowCanvas = this.shadowCanvas = document.createElement('canvas');
    var canvas = this.canvas = config.canvas || document.createElement('canvas');
    var renderBoundaries = this._renderBoundaries = [10000, 10000, 0, 0];

    var computed = getComputedStyle(config.container) || {};

    canvas.className = 'heatmap-canvas';

    this._width = canvas.width = shadowCanvas.width = config.width || +(computed.width.replace(/px/,''));
    this._height = canvas.height = shadowCanvas.height = config.height || +(computed.height.replace(/px/,''));

    this.shadowCtx = shadowCanvas.getContext('2d');
    this.ctx = canvas.getContext('2d');

    // @TODO:
    // conditional wrapper

    canvas.style.cssText = shadowCanvas.style.cssText = 'position:absolute;left:0;top:0;';

    container.style.position = 'relative';
    container.appendChild(canvas);

    this._palette = _getColorPalette(config);
    this._templates = {};

    this._setStyles(config);
  };

  Canvas2dRenderer.prototype = {
    renderPartial: function(data) {
      if (data.data.length > 0) {
        this._drawAlpha(data);
        this._colorize();
      }
    },
    renderAll: function(data) {
      // reset render boundaries
      this._clear();
      if (data.data.length > 0) {
        this._drawAlpha(_prepareData(data));
        this._colorize();
      }
    },
    _updateGradient: function(config) {
      this._palette = _getColorPalette(config);
    },
    updateConfig: function(config) {
      if (config['gradient']) {
        this._updateGradient(config);
      }
      this._setStyles(config);
    },
    setDimensions: function(width, height) {
      this._width = width;
      this._height = height;
      this.canvas.width = this.shadowCanvas.width = width;
      this.canvas.height = this.shadowCanvas.height = height;
    },
    _clear: function() {
      this.shadowCtx.clearRect(0, 0, this._width, this._height);
      this.ctx.clearRect(0, 0, this._width, this._height);
    },
    _setStyles: function(config) {
      this._blur = (config.blur == 0)?0:(config.blur || config.defaultBlur);

      if (config.backgroundColor) {
        this.canvas.style.backgroundColor = config.backgroundColor;
      }

      this._width = this.canvas.width = this.shadowCanvas.width = config.width || this._width;
      this._height = this.canvas.height = this.shadowCanvas.height = config.height || this._height;


      this._opacity = (config.opacity || 0) * 255;
      this._maxOpacity = (config.maxOpacity || config.defaultMaxOpacity) * 255;
      this._minOpacity = (config.minOpacity || config.defaultMinOpacity) * 255;
      this._useGradientOpacity = !!config.useGradientOpacity;
    },
    _drawAlpha: function(data) {
      var min = this._min = data.min;
      var max = this._max = data.max;
      var data = data.data || [];
      var dataLen = data.length;
      // on a point basis?
      var blur = 1 - this._blur;

      while(dataLen--) {

        var point = data[dataLen];

        var x = point.x;
        var y = point.y;
        var radius = point.radius;
        // if value is bigger than max
        // use max as value
        var value = Math.min(point.value, max);
        var rectX = x - radius;
        var rectY = y - radius;
        var shadowCtx = this.shadowCtx;




        var tpl;
        if (!this._templates[radius]) {
          this._templates[radius] = tpl = _getPointTemplate(radius, blur);
        } else {
          tpl = this._templates[radius];
        }
        // value from minimum / value range
        // => [0, 1]
        var templateAlpha = (value-min)/(max-min);
        // this fixes #176: small values are not visible because globalAlpha < .01 cannot be read from imageData
        shadowCtx.globalAlpha = templateAlpha < .01 ? .01 : templateAlpha;

        shadowCtx.drawImage(tpl, rectX, rectY);

        // update renderBoundaries
        if (rectX < this._renderBoundaries[0]) {
            this._renderBoundaries[0] = rectX;
          }
          if (rectY < this._renderBoundaries[1]) {
            this._renderBoundaries[1] = rectY;
          }
          if (rectX + 2*radius > this._renderBoundaries[2]) {
            this._renderBoundaries[2] = rectX + 2*radius;
          }
          if (rectY + 2*radius > this._renderBoundaries[3]) {
            this._renderBoundaries[3] = rectY + 2*radius;
          }

      }
    },
    _colorize: function() {
      var x = this._renderBoundaries[0];
      var y = this._renderBoundaries[1];
      var width = this._renderBoundaries[2] - x;
      var height = this._renderBoundaries[3] - y;
      var maxWidth = this._width;
      var maxHeight = this._height;
      var opacity = this._opacity;
      var maxOpacity = this._maxOpacity;
      var minOpacity = this._minOpacity;
      var useGradientOpacity = this._useGradientOpacity;

      if (x < 0) {
        x = 0;
      }
      if (y < 0) {
        y = 0;
      }
      if (x + width > maxWidth) {
        width = maxWidth - x;
      }
      if (y + height > maxHeight) {
        height = maxHeight - y;
      }

      var img = this.shadowCtx.getImageData(x, y, width, height);
      var imgData = img.data;
      var len = imgData.length;
      var palette = this._palette;


      for (var i = 3; i < len; i+= 4) {
        var alpha = imgData[i];
        var offset = alpha * 4;


        if (!offset) {
          continue;
        }

        var finalAlpha;
        if (opacity > 0) {
          finalAlpha = opacity;
        } else {
          if (alpha < maxOpacity) {
            if (alpha < minOpacity) {
              finalAlpha = minOpacity;
            } else {
              finalAlpha = alpha;
            }
          } else {
            finalAlpha = maxOpacity;
          }
        }

        imgData[i-3] = palette[offset];
        imgData[i-2] = palette[offset + 1];
        imgData[i-1] = palette[offset + 2];
        imgData[i] = useGradientOpacity ? palette[offset + 3] : finalAlpha;

      }

      img.data = imgData;
      this.ctx.putImageData(img, x, y);

      this._renderBoundaries = [1000, 1000, 0, 0];

    },
    getValueAt: function(point) {
      var value;
      var shadowCtx = this.shadowCtx;
      var img = shadowCtx.getImageData(point.x, point.y, 1, 1);
      var data = img.data[3];
      var max = this._max;
      var min = this._min;

      value = (Math.abs(max-min) * (data/255)) >> 0;

      return value;
    },
    getDataURL: function() {
      return this.canvas.toDataURL();
    }
  };


  return Canvas2dRenderer;
})();


var Renderer = (function RendererClosure() {

  var rendererFn = false;

  if (HeatmapConfig['defaultRenderer'] === 'canvas2d') {
    rendererFn = Canvas2dRenderer;
  }

  return rendererFn;
})();


var Util = {
  merge: function() {
    var merged = {};
    var argsLen = arguments.length;
    for (var i = 0; i < argsLen; i++) {
      var obj = arguments[i]
      for (var key in obj) {
        merged[key] = obj[key];
      }
    }
    return merged;
  }
};
// Heatmap Constructor
var Heatmap = (function HeatmapClosure() {

  var Coordinator = (function CoordinatorClosure() {

    function Coordinator() {
      this.cStore = {};
    };

    Coordinator.prototype = {
      on: function(evtName, callback, scope) {
        var cStore = this.cStore;

        if (!cStore[evtName]) {
          cStore[evtName] = [];
        }
        cStore[evtName].push((function(data) {
            return callback.call(scope, data);
        }));
      },
      emit: function(evtName, data) {
        var cStore = this.cStore;
        if (cStore[evtName]) {
          var len = cStore[evtName].length;
          for (var i=0; i<len; i++) {
            var callback = cStore[evtName][i];
            callback(data);
          }
        }
      }
    };

    return Coordinator;
  })();


  var _connect = function(scope) {
    var renderer = scope._renderer;
    var coordinator = scope._coordinator;
    var store = scope._store;

    coordinator.on('renderpartial', renderer.renderPartial, renderer);
    coordinator.on('renderall', renderer.renderAll, renderer);
    coordinator.on('extremachange', function(data) {
      scope._config.onExtremaChange &&
      scope._config.onExtremaChange({
        min: data.min,
        max: data.max,
        gradient: scope._config['gradient'] || scope._config['defaultGradient']
      });
    });
    store.setCoordinator(coordinator);
  };


  function Heatmap() {
    var config = this._config = Util.merge(HeatmapConfig, arguments[0] || {});
    this._coordinator = new Coordinator();
    if (config['plugin']) {
      var pluginToLoad = config['plugin'];
      if (!HeatmapConfig.plugins[pluginToLoad]) {
        throw new Error('Plugin \''+ pluginToLoad + '\' not found. Maybe it was not registered.');
      } else {
        var plugin = HeatmapConfig.plugins[pluginToLoad];
        // set plugin renderer and store
        this._renderer = new plugin.renderer(config);
        this._store = new plugin.store(config);
      }
    } else {
      this._renderer = new Renderer(config);
      this._store = new Store(config);
    }
    _connect(this);
  };

  // @TODO:
  // add API documentation
  Heatmap.prototype = {
    addData: function() {
      this._store.addData.apply(this._store, arguments);
      return this;
    },
    removeData: function() {
      this._store.removeData && this._store.removeData.apply(this._store, arguments);
      return this;
    },
    setData: function() {
      this._store.setData.apply(this._store, arguments);
      return this;
    },
    setDataMax: function() {
      this._store.setDataMax.apply(this._store, arguments);
      return this;
    },
    setDataMin: function() {
      this._store.setDataMin.apply(this._store, arguments);
      return this;
    },
    configure: function(config) {
      this._config = Util.merge(this._config, config);
      this._renderer.updateConfig(this._config);
      this._coordinator.emit('renderall', this._store._getInternalData());
      return this;
    },
    repaint: function() {
      this._coordinator.emit('renderall', this._store._getInternalData());
      return this;
    },
    getData: function() {
      return this._store.getData();
    },
    getDataURL: function() {
      return this._renderer.getDataURL();
    },
    getValueAt: function(point) {

      if (this._store.getValueAt) {
        return this._store.getValueAt(point);
      } else  if (this._renderer.getValueAt) {
        return this._renderer.getValueAt(point);
      } else {
        return null;
      }
    }
  };

  return Heatmap;

})();


// core
var heatmapFactory = {
  create: function(config) {
    return new Heatmap(config);
  },
  register: function(pluginKey, plugin) {
    HeatmapConfig.plugins[pluginKey] = plugin;
  }
};

return heatmapFactory;


});
},{}],2:[function(require,module,exports){
"use strict";

var _heatmap = _interopRequireDefault(require("../lib/node_modules/heatmap.js/build/heatmap.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import heatmapControl from "./heatmapControl"
// var heatmapjs = require("../lib/node_modules/heatmapjs/heatmap.min.js");
const mapContainer = document.getElementById("container");
let varWidth = mapContainer.offsetWidth;
let varHeight = mapContainer.offsetHeight;
var config = {
  container: mapContainer,
  radius: 80,
  maxOpacity: .5,
  minOpacity: 0,
  blur: .75,
  backgroundColor: "rgba(206,231,255,.95)"
}; // create heatmap with configuration

let heatmapInstance;
console.log(_heatmap.default);

function buildHeatmap() {
  heatmapInstance = _heatmap.default.create(config);
  console.log(heatmapInstance);
  var dataPoints = [];

  for (let i = 0; i < 100; i++) {
    let x_ = Math.floor(Math.random() * varWidth);
    let y_ = Math.floor(Math.random() * varHeight);
    let value_ = Math.floor(Math.random() * 100);
    let obj = {
      x: x_,
      y: y_,
      value: value_
    };

    if (x_ === 0 || y_ === 0 || value_ === 0) {
      console.log("ZERO", x_, y_, value_);
    } // console.log(obj.x, obj.y, obj.value)


    dataPoints.push(obj);
  }

  const data = {
    max: 100,
    min: 0,
    data: dataPoints
  };
  heatmapInstance.setData(data);
}

buildHeatmap(); // determine container dimensions at a certain interval.
// if

function getActiveOffsets() {
  const captureWidth = mapContainer.offsetWidth; // const captureHeight = mapContainer.offsetHeight
  //evaluate container width after 0.5 seconds vs initial container width

  if (captureWidth === varWidth) {
    console.log("unchanged");
  } else {
    varWidth = captureWidth;
    console.log("new width", varWidth); //clear heatmap

    mapContainer.removeChild(mapContainer.childNodes[0]); //build heatmap again

    buildHeatmap();
  }
}

setInterval(getActiveOffsets, 500);

},{"../lib/node_modules/heatmap.js/build/heatmap.js":1}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvaGVhdG1hcC5qcy9idWlsZC9oZWF0bWFwLmpzIiwiLi4vc2NyaXB0cy9tYWluLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqdEJBOzs7O0FBRkE7QUFDQTtBQUdBLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxjQUFULENBQXdCLFdBQXhCLENBQXJCO0FBQ0EsSUFBSSxRQUFRLEdBQUcsWUFBWSxDQUFDLFdBQTVCO0FBQ0EsSUFBSSxTQUFTLEdBQUcsWUFBWSxDQUFDLFlBQTdCO0FBRUEsSUFBSSxNQUFNLEdBQUc7QUFDWCxFQUFBLFNBQVMsRUFBRSxZQURBO0FBRVgsRUFBQSxNQUFNLEVBQUUsRUFGRztBQUdYLEVBQUEsVUFBVSxFQUFFLEVBSEQ7QUFJWCxFQUFBLFVBQVUsRUFBRSxDQUpEO0FBS1gsRUFBQSxJQUFJLEVBQUUsR0FMSztBQU1YLEVBQUEsZUFBZSxFQUFFO0FBTk4sQ0FBYixDLENBUUE7O0FBQ0EsSUFBSSxlQUFKO0FBRUEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxnQkFBWjs7QUFFQSxTQUFTLFlBQVQsR0FBd0I7QUFFdEIsRUFBQSxlQUFlLEdBQUcsaUJBQVEsTUFBUixDQUFlLE1BQWYsQ0FBbEI7QUFDQSxFQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksZUFBWjtBQUVBLE1BQUksVUFBVSxHQUFHLEVBQWpCOztBQUNBLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBYixFQUFnQixDQUFDLEdBQUcsR0FBcEIsRUFBeUIsQ0FBQyxFQUExQixFQUE4QjtBQUM1QixRQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLElBQUksQ0FBQyxNQUFMLEtBQWdCLFFBQTNCLENBQVQ7QUFDQSxRQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLElBQUksQ0FBQyxNQUFMLEtBQWdCLFNBQTNCLENBQVQ7QUFDQSxRQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLElBQUksQ0FBQyxNQUFMLEtBQWdCLEdBQTNCLENBQWI7QUFFQSxRQUFJLEdBQUcsR0FBRztBQUFFLE1BQUEsQ0FBQyxFQUFFLEVBQUw7QUFBUyxNQUFBLENBQUMsRUFBRSxFQUFaO0FBQWdCLE1BQUEsS0FBSyxFQUFFO0FBQXZCLEtBQVY7O0FBRUEsUUFBSSxFQUFFLEtBQUssQ0FBUCxJQUFZLEVBQUUsS0FBSyxDQUFuQixJQUF3QixNQUFNLEtBQUssQ0FBdkMsRUFBMEM7QUFDeEMsTUFBQSxPQUFPLENBQUMsR0FBUixDQUFZLE1BQVosRUFBb0IsRUFBcEIsRUFBd0IsRUFBeEIsRUFBNEIsTUFBNUI7QUFDRCxLQVQyQixDQVc1Qjs7O0FBQ0EsSUFBQSxVQUFVLENBQUMsSUFBWCxDQUFnQixHQUFoQjtBQUNEOztBQUVELFFBQU0sSUFBSSxHQUFHO0FBQ1gsSUFBQSxHQUFHLEVBQUUsR0FETTtBQUVYLElBQUEsR0FBRyxFQUFFLENBRk07QUFHWCxJQUFBLElBQUksRUFBRTtBQUhLLEdBQWI7QUFNQSxFQUFBLGVBQWUsQ0FBQyxPQUFoQixDQUF3QixJQUF4QjtBQUNEOztBQUVELFlBQVksRyxDQUVaO0FBQ0E7O0FBQ0EsU0FBUyxnQkFBVCxHQUE0QjtBQUMxQixRQUFNLFlBQVksR0FBRyxZQUFZLENBQUMsV0FBbEMsQ0FEMEIsQ0FFMUI7QUFDQTs7QUFDQSxNQUFJLFlBQVksS0FBSyxRQUFyQixFQUErQjtBQUM3QixJQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksV0FBWjtBQUNELEdBRkQsTUFFTztBQUNMLElBQUEsUUFBUSxHQUFHLFlBQVg7QUFDQSxJQUFBLE9BQU8sQ0FBQyxHQUFSLENBQVksV0FBWixFQUF5QixRQUF6QixFQUZLLENBR0w7O0FBQ0EsSUFBQSxZQUFZLENBQUMsV0FBYixDQUF5QixZQUFZLENBQUMsVUFBYixDQUF3QixDQUF4QixDQUF6QixFQUpLLENBS0w7O0FBQ0EsSUFBQSxZQUFZO0FBQ2I7QUFDRjs7QUFFRCxXQUFXLENBQUMsZ0JBQUQsRUFBbUIsR0FBbkIsQ0FBWCIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qXG4gKiBoZWF0bWFwLmpzIHYyLjAuNSB8IEphdmFTY3JpcHQgSGVhdG1hcCBMaWJyYXJ5XG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAxNiBQYXRyaWNrIFdpZWQgPGhlYXRtYXBqc0BwYXRyaWNrLXdpZWQuYXQ+IC0gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIER1YWwgbGljZW5zZWQgdW5kZXIgTUlUIGFuZCBCZWVyd2FyZSBsaWNlbnNlIFxuICpcbiAqIDo6IDIwMTYtMDktMDUgMDE6MTZcbiAqL1xuOyhmdW5jdGlvbiAobmFtZSwgY29udGV4dCwgZmFjdG9yeSkge1xuXG4gIC8vIFN1cHBvcnRzIFVNRC4gQU1ELCBDb21tb25KUy9Ob2RlLmpzIGFuZCBicm93c2VyIGNvbnRleHRcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmYWN0b3J5KTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0W25hbWVdID0gZmFjdG9yeSgpO1xuICB9XG5cbn0pKFwiaDMzN1wiLCB0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbi8vIEhlYXRtYXAgQ29uZmlnIHN0b3JlcyBkZWZhdWx0IHZhbHVlcyBhbmQgd2lsbCBiZSBtZXJnZWQgd2l0aCBpbnN0YW5jZSBjb25maWdcbnZhciBIZWF0bWFwQ29uZmlnID0ge1xuICBkZWZhdWx0UmFkaXVzOiA0MCxcbiAgZGVmYXVsdFJlbmRlcmVyOiAnY2FudmFzMmQnLFxuICBkZWZhdWx0R3JhZGllbnQ6IHsgMC4yNTogXCJyZ2IoMCwwLDI1NSlcIiwgMC41NTogXCJyZ2IoMCwyNTUsMClcIiwgMC44NTogXCJ5ZWxsb3dcIiwgMS4wOiBcInJnYigyNTUsMCwwKVwifSxcbiAgZGVmYXVsdE1heE9wYWNpdHk6IDEsXG4gIGRlZmF1bHRNaW5PcGFjaXR5OiAwLFxuICBkZWZhdWx0Qmx1cjogLjg1LFxuICBkZWZhdWx0WEZpZWxkOiAneCcsXG4gIGRlZmF1bHRZRmllbGQ6ICd5JyxcbiAgZGVmYXVsdFZhbHVlRmllbGQ6ICd2YWx1ZScsIFxuICBwbHVnaW5zOiB7fVxufTtcbnZhciBTdG9yZSA9IChmdW5jdGlvbiBTdG9yZUNsb3N1cmUoKSB7XG5cbiAgdmFyIFN0b3JlID0gZnVuY3Rpb24gU3RvcmUoY29uZmlnKSB7XG4gICAgdGhpcy5fY29vcmRpbmF0b3IgPSB7fTtcbiAgICB0aGlzLl9kYXRhID0gW107XG4gICAgdGhpcy5fcmFkaSA9IFtdO1xuICAgIHRoaXMuX21pbiA9IDEwO1xuICAgIHRoaXMuX21heCA9IDE7XG4gICAgdGhpcy5feEZpZWxkID0gY29uZmlnWyd4RmllbGQnXSB8fCBjb25maWcuZGVmYXVsdFhGaWVsZDtcbiAgICB0aGlzLl95RmllbGQgPSBjb25maWdbJ3lGaWVsZCddIHx8IGNvbmZpZy5kZWZhdWx0WUZpZWxkO1xuICAgIHRoaXMuX3ZhbHVlRmllbGQgPSBjb25maWdbJ3ZhbHVlRmllbGQnXSB8fCBjb25maWcuZGVmYXVsdFZhbHVlRmllbGQ7XG5cbiAgICBpZiAoY29uZmlnW1wicmFkaXVzXCJdKSB7XG4gICAgICB0aGlzLl9jZmdSYWRpdXMgPSBjb25maWdbXCJyYWRpdXNcIl07XG4gICAgfVxuICB9O1xuXG4gIHZhciBkZWZhdWx0UmFkaXVzID0gSGVhdG1hcENvbmZpZy5kZWZhdWx0UmFkaXVzO1xuXG4gIFN0b3JlLnByb3RvdHlwZSA9IHtcbiAgICAvLyB3aGVuIGZvcmNlUmVuZGVyID0gZmFsc2UgLT4gY2FsbGVkIGZyb20gc2V0RGF0YSwgb21pdHMgcmVuZGVyYWxsIGV2ZW50XG4gICAgX29yZ2FuaXNlRGF0YTogZnVuY3Rpb24oZGF0YVBvaW50LCBmb3JjZVJlbmRlcikge1xuICAgICAgICB2YXIgeCA9IGRhdGFQb2ludFt0aGlzLl94RmllbGRdO1xuICAgICAgICB2YXIgeSA9IGRhdGFQb2ludFt0aGlzLl95RmllbGRdO1xuICAgICAgICB2YXIgcmFkaSA9IHRoaXMuX3JhZGk7XG4gICAgICAgIHZhciBzdG9yZSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLl9tYXg7XG4gICAgICAgIHZhciBtaW4gPSB0aGlzLl9taW47XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGFQb2ludFt0aGlzLl92YWx1ZUZpZWxkXSB8fCAxO1xuICAgICAgICB2YXIgcmFkaXVzID0gZGF0YVBvaW50LnJhZGl1cyB8fCB0aGlzLl9jZmdSYWRpdXMgfHwgZGVmYXVsdFJhZGl1cztcblxuICAgICAgICBpZiAoIXN0b3JlW3hdKSB7XG4gICAgICAgICAgc3RvcmVbeF0gPSBbXTtcbiAgICAgICAgICByYWRpW3hdID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0b3JlW3hdW3ldKSB7XG4gICAgICAgICAgc3RvcmVbeF1beV0gPSB2YWx1ZTtcbiAgICAgICAgICByYWRpW3hdW3ldID0gcmFkaXVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0b3JlW3hdW3ldICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdG9yZWRWYWwgPSBzdG9yZVt4XVt5XTtcblxuICAgICAgICBpZiAoc3RvcmVkVmFsID4gbWF4KSB7XG4gICAgICAgICAgaWYgKCFmb3JjZVJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5fbWF4ID0gc3RvcmVkVmFsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGFNYXgoc3RvcmVkVmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0b3JlZFZhbCA8IG1pbikge1xuICAgICAgICAgIGlmICghZm9yY2VSZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX21pbiA9IHN0b3JlZFZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXREYXRhTWluKHN0b3JlZFZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyBcbiAgICAgICAgICAgIHg6IHgsIFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSwgXG4gICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgIG1pbjogbWluLFxuICAgICAgICAgICAgbWF4OiBtYXggXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3VuT3JnYW5pemVEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1bm9yZ2FuaXplZERhdGEgPSBbXTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgIHZhciByYWRpID0gdGhpcy5fcmFkaTtcblxuICAgICAgZm9yICh2YXIgeCBpbiBkYXRhKSB7XG4gICAgICAgIGZvciAodmFyIHkgaW4gZGF0YVt4XSkge1xuXG4gICAgICAgICAgdW5vcmdhbml6ZWREYXRhLnB1c2goe1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICByYWRpdXM6IHJhZGlbeF1beV0sXG4gICAgICAgICAgICB2YWx1ZTogZGF0YVt4XVt5XVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogdGhpcy5fbWluLFxuICAgICAgICBtYXg6IHRoaXMuX21heCxcbiAgICAgICAgZGF0YTogdW5vcmdhbml6ZWREYXRhXG4gICAgICB9O1xuICAgIH0sXG4gICAgX29uRXh0cmVtYUNoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb29yZGluYXRvci5lbWl0KCdleHRyZW1hY2hhbmdlJywge1xuICAgICAgICBtaW46IHRoaXMuX21pbixcbiAgICAgICAgbWF4OiB0aGlzLl9tYXhcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWRkRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzBdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGRhdGFBcnIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBkYXRhTGVuID0gZGF0YUFyci5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChkYXRhTGVuLS0pIHtcbiAgICAgICAgICB0aGlzLmFkZERhdGEuY2FsbCh0aGlzLCBkYXRhQXJyW2RhdGFMZW5dKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkIHRvIHN0b3JlICBcbiAgICAgICAgdmFyIG9yZ2FuaXNlZEVudHJ5ID0gdGhpcy5fb3JnYW5pc2VEYXRhKGFyZ3VtZW50c1swXSwgdHJ1ZSk7XG4gICAgICAgIGlmIChvcmdhbmlzZWRFbnRyeSkge1xuICAgICAgICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0IGRhdGFwb2ludCBpbml0aWFsaXplIHRoZSBleHRyZW1hcyB3aXRoIGl0XG4gICAgICAgICAgaWYgKHRoaXMuX2RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9taW4gPSB0aGlzLl9tYXggPSBvcmdhbmlzZWRFbnRyeS52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY29vcmRpbmF0b3IuZW1pdCgncmVuZGVycGFydGlhbCcsIHtcbiAgICAgICAgICAgIG1pbjogdGhpcy5fbWluLFxuICAgICAgICAgICAgbWF4OiB0aGlzLl9tYXgsXG4gICAgICAgICAgICBkYXRhOiBbb3JnYW5pc2VkRW50cnldXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGRhdGFQb2ludHMgPSBkYXRhLmRhdGE7XG4gICAgICB2YXIgcG9pbnRzTGVuID0gZGF0YVBvaW50cy5sZW5ndGg7XG5cblxuICAgICAgLy8gcmVzZXQgZGF0YSBhcnJheXNcbiAgICAgIHRoaXMuX2RhdGEgPSBbXTtcbiAgICAgIHRoaXMuX3JhZGkgPSBbXTtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBvaW50c0xlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuX29yZ2FuaXNlRGF0YShkYXRhUG9pbnRzW2ldLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXggPSBkYXRhLm1heDtcbiAgICAgIHRoaXMuX21pbiA9IGRhdGEubWluIHx8IDA7XG4gICAgICBcbiAgICAgIHRoaXMuX29uRXh0cmVtYUNoYW5nZSgpO1xuICAgICAgdGhpcy5fY29vcmRpbmF0b3IuZW1pdCgncmVuZGVyYWxsJywgdGhpcy5fZ2V0SW50ZXJuYWxEYXRhKCkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmVEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRPRE86IGltcGxlbWVudFxuICAgIH0sXG4gICAgc2V0RGF0YU1heDogZnVuY3Rpb24obWF4KSB7XG4gICAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgICB0aGlzLl9vbkV4dHJlbWFDaGFuZ2UoKTtcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdG9yLmVtaXQoJ3JlbmRlcmFsbCcsIHRoaXMuX2dldEludGVybmFsRGF0YSgpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0RGF0YU1pbjogZnVuY3Rpb24obWluKSB7XG4gICAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgICB0aGlzLl9vbkV4dHJlbWFDaGFuZ2UoKTtcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdG9yLmVtaXQoJ3JlbmRlcmFsbCcsIHRoaXMuX2dldEludGVybmFsRGF0YSgpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0Q29vcmRpbmF0b3I6IGZ1bmN0aW9uKGNvb3JkaW5hdG9yKSB7XG4gICAgICB0aGlzLl9jb29yZGluYXRvciA9IGNvb3JkaW5hdG9yO1xuICAgIH0sXG4gICAgX2dldEludGVybmFsRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geyBcbiAgICAgICAgbWF4OiB0aGlzLl9tYXgsXG4gICAgICAgIG1pbjogdGhpcy5fbWluLCBcbiAgICAgICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICAgICAgcmFkaTogdGhpcy5fcmFkaSBcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl91bk9yZ2FuaXplRGF0YSgpO1xuICAgIH0vKixcblxuICAgICAgVE9ETzogcmV0aGluay5cblxuICAgIGdldFZhbHVlQXQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgcmFkaXVzID0gMTAwO1xuICAgICAgdmFyIHggPSBwb2ludC54O1xuICAgICAgdmFyIHkgPSBwb2ludC55O1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXG4gICAgICBpZiAoZGF0YVt4XSAmJiBkYXRhW3hdW3ldKSB7XG4gICAgICAgIHJldHVybiBkYXRhW3hdW3ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAvLyByYWRpYWwgc2VhcmNoIGZvciBkYXRhcG9pbnRzIGJhc2VkIG9uIGRlZmF1bHQgcmFkaXVzXG4gICAgICAgIGZvcih2YXIgZGlzdGFuY2UgPSAxOyBkaXN0YW5jZSA8IHJhZGl1czsgZGlzdGFuY2UrKykge1xuICAgICAgICAgIHZhciBuZWlnaGJvcnMgPSBkaXN0YW5jZSAqIDIgKzE7XG4gICAgICAgICAgdmFyIHN0YXJ0WCA9IHggLSBkaXN0YW5jZTtcbiAgICAgICAgICB2YXIgc3RhcnRZID0geSAtIGRpc3RhbmNlO1xuXG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5laWdoYm9yczsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IG5laWdoYm9yczsgbysrKSB7XG4gICAgICAgICAgICAgIGlmICgoaSA9PSAwIHx8IGkgPT0gbmVpZ2hib3JzLTEpIHx8IChvID09IDAgfHwgbyA9PSBuZWlnaGJvcnMtMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVtzdGFydFkraV0gJiYgZGF0YVtzdGFydFkraV1bc3RhcnRYK29dKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChkYXRhW3N0YXJ0WStpXVtzdGFydFgrb10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9Ki9cbiAgfTtcblxuXG4gIHJldHVybiBTdG9yZTtcbn0pKCk7XG5cbnZhciBDYW52YXMyZFJlbmRlcmVyID0gKGZ1bmN0aW9uIENhbnZhczJkUmVuZGVyZXJDbG9zdXJlKCkge1xuXG4gIHZhciBfZ2V0Q29sb3JQYWxldHRlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdmFyIGdyYWRpZW50Q29uZmlnID0gY29uZmlnLmdyYWRpZW50IHx8IGNvbmZpZy5kZWZhdWx0R3JhZGllbnQ7XG4gICAgdmFyIHBhbGV0dGVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgcGFsZXR0ZUN0eCA9IHBhbGV0dGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIHBhbGV0dGVDYW52YXMud2lkdGggPSAyNTY7XG4gICAgcGFsZXR0ZUNhbnZhcy5oZWlnaHQgPSAxO1xuXG4gICAgdmFyIGdyYWRpZW50ID0gcGFsZXR0ZUN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCAyNTYsIDEpO1xuICAgIGZvciAodmFyIGtleSBpbiBncmFkaWVudENvbmZpZykge1xuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKGtleSwgZ3JhZGllbnRDb25maWdba2V5XSk7XG4gICAgfVxuXG4gICAgcGFsZXR0ZUN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICBwYWxldHRlQ3R4LmZpbGxSZWN0KDAsIDAsIDI1NiwgMSk7XG5cbiAgICByZXR1cm4gcGFsZXR0ZUN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMjU2LCAxKS5kYXRhO1xuICB9O1xuXG4gIHZhciBfZ2V0UG9pbnRUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJhZGl1cywgYmx1ckZhY3Rvcikge1xuICAgIHZhciB0cGxDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgdHBsQ3R4ID0gdHBsQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdmFyIHggPSByYWRpdXM7XG4gICAgdmFyIHkgPSByYWRpdXM7XG4gICAgdHBsQ2FudmFzLndpZHRoID0gdHBsQ2FudmFzLmhlaWdodCA9IHJhZGl1cyoyO1xuXG4gICAgaWYgKGJsdXJGYWN0b3IgPT0gMSkge1xuICAgICAgdHBsQ3R4LmJlZ2luUGF0aCgpO1xuICAgICAgdHBsQ3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJLCBmYWxzZSk7XG4gICAgICB0cGxDdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMSknO1xuICAgICAgdHBsQ3R4LmZpbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGdyYWRpZW50ID0gdHBsQ3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHgsIHksIHJhZGl1cypibHVyRmFjdG9yLCB4LCB5LCByYWRpdXMpO1xuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICdyZ2JhKDAsMCwwLDEpJyk7XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJ3JnYmEoMCwwLDAsMCknKTtcbiAgICAgIHRwbEN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgIHRwbEN0eC5maWxsUmVjdCgwLCAwLCAyKnJhZGl1cywgMipyYWRpdXMpO1xuICAgIH1cblxuXG5cbiAgICByZXR1cm4gdHBsQ2FudmFzO1xuICB9O1xuXG4gIHZhciBfcHJlcGFyZURhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHJlbmRlckRhdGEgPSBbXTtcbiAgICB2YXIgbWluID0gZGF0YS5taW47XG4gICAgdmFyIG1heCA9IGRhdGEubWF4O1xuICAgIHZhciByYWRpID0gZGF0YS5yYWRpO1xuICAgIHZhciBkYXRhID0gZGF0YS5kYXRhO1xuXG4gICAgdmFyIHhWYWx1ZXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICB2YXIgeFZhbHVlc0xlbiA9IHhWYWx1ZXMubGVuZ3RoO1xuXG4gICAgd2hpbGUoeFZhbHVlc0xlbi0tKSB7XG4gICAgICB2YXIgeFZhbHVlID0geFZhbHVlc1t4VmFsdWVzTGVuXTtcbiAgICAgIHZhciB5VmFsdWVzID0gT2JqZWN0LmtleXMoZGF0YVt4VmFsdWVdKTtcbiAgICAgIHZhciB5VmFsdWVzTGVuID0geVZhbHVlcy5sZW5ndGg7XG4gICAgICB3aGlsZSh5VmFsdWVzTGVuLS0pIHtcbiAgICAgICAgdmFyIHlWYWx1ZSA9IHlWYWx1ZXNbeVZhbHVlc0xlbl07XG4gICAgICAgIHZhciB2YWx1ZSA9IGRhdGFbeFZhbHVlXVt5VmFsdWVdO1xuICAgICAgICB2YXIgcmFkaXVzID0gcmFkaVt4VmFsdWVdW3lWYWx1ZV07XG4gICAgICAgIHJlbmRlckRhdGEucHVzaCh7XG4gICAgICAgICAgeDogeFZhbHVlLFxuICAgICAgICAgIHk6IHlWYWx1ZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcmFkaXVzOiByYWRpdXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXgsXG4gICAgICBkYXRhOiByZW5kZXJEYXRhXG4gICAgfTtcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIENhbnZhczJkUmVuZGVyZXIoY29uZmlnKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXI7XG4gICAgdmFyIHNoYWRvd0NhbnZhcyA9IHRoaXMuc2hhZG93Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzID0gY29uZmlnLmNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB2YXIgcmVuZGVyQm91bmRhcmllcyA9IHRoaXMuX3JlbmRlckJvdW5kYXJpZXMgPSBbMTAwMDAsIDEwMDAwLCAwLCAwXTtcblxuICAgIHZhciBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUoY29uZmlnLmNvbnRhaW5lcikgfHwge307XG5cbiAgICBjYW52YXMuY2xhc3NOYW1lID0gJ2hlYXRtYXAtY2FudmFzJztcblxuICAgIHRoaXMuX3dpZHRoID0gY2FudmFzLndpZHRoID0gc2hhZG93Q2FudmFzLndpZHRoID0gY29uZmlnLndpZHRoIHx8ICsoY29tcHV0ZWQud2lkdGgucmVwbGFjZSgvcHgvLCcnKSk7XG4gICAgdGhpcy5faGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IHNoYWRvd0NhbnZhcy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0IHx8ICsoY29tcHV0ZWQuaGVpZ2h0LnJlcGxhY2UoL3B4LywnJykpO1xuXG4gICAgdGhpcy5zaGFkb3dDdHggPSBzaGFkb3dDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgLy8gQFRPRE86XG4gICAgLy8gY29uZGl0aW9uYWwgd3JhcHBlclxuXG4gICAgY2FudmFzLnN0eWxlLmNzc1RleHQgPSBzaGFkb3dDYW52YXMuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7dG9wOjA7JztcblxuICAgIGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG5cbiAgICB0aGlzLl9wYWxldHRlID0gX2dldENvbG9yUGFsZXR0ZShjb25maWcpO1xuICAgIHRoaXMuX3RlbXBsYXRlcyA9IHt9O1xuXG4gICAgdGhpcy5fc2V0U3R5bGVzKGNvbmZpZyk7XG4gIH07XG5cbiAgQ2FudmFzMmRSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gICAgcmVuZGVyUGFydGlhbDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgaWYgKGRhdGEuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX2RyYXdBbHBoYShkYXRhKTtcbiAgICAgICAgdGhpcy5fY29sb3JpemUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckFsbDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgLy8gcmVzZXQgcmVuZGVyIGJvdW5kYXJpZXNcbiAgICAgIHRoaXMuX2NsZWFyKCk7XG4gICAgICBpZiAoZGF0YS5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fZHJhd0FscGhhKF9wcmVwYXJlRGF0YShkYXRhKSk7XG4gICAgICAgIHRoaXMuX2NvbG9yaXplKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfdXBkYXRlR3JhZGllbnQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdGhpcy5fcGFsZXR0ZSA9IF9nZXRDb2xvclBhbGV0dGUoY29uZmlnKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbmZpZzogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnWydncmFkaWVudCddKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUdyYWRpZW50KGNvbmZpZyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRTdHlsZXMoY29uZmlnKTtcbiAgICB9LFxuICAgIHNldERpbWVuc2lvbnM6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuc2hhZG93Q2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLnNoYWRvd0NhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfSxcbiAgICBfY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zaGFkb3dDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIH0sXG4gICAgX3NldFN0eWxlczogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB0aGlzLl9ibHVyID0gKGNvbmZpZy5ibHVyID09IDApPzA6KGNvbmZpZy5ibHVyIHx8IGNvbmZpZy5kZWZhdWx0Qmx1cik7XG5cbiAgICAgIGlmIChjb25maWcuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbmZpZy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLnNoYWRvd0NhbnZhcy53aWR0aCA9IGNvbmZpZy53aWR0aCB8fCB0aGlzLl93aWR0aDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuc2hhZG93Q2FudmFzLmhlaWdodCA9IGNvbmZpZy5oZWlnaHQgfHwgdGhpcy5faGVpZ2h0O1xuXG5cbiAgICAgIHRoaXMuX29wYWNpdHkgPSAoY29uZmlnLm9wYWNpdHkgfHwgMCkgKiAyNTU7XG4gICAgICB0aGlzLl9tYXhPcGFjaXR5ID0gKGNvbmZpZy5tYXhPcGFjaXR5IHx8IGNvbmZpZy5kZWZhdWx0TWF4T3BhY2l0eSkgKiAyNTU7XG4gICAgICB0aGlzLl9taW5PcGFjaXR5ID0gKGNvbmZpZy5taW5PcGFjaXR5IHx8IGNvbmZpZy5kZWZhdWx0TWluT3BhY2l0eSkgKiAyNTU7XG4gICAgICB0aGlzLl91c2VHcmFkaWVudE9wYWNpdHkgPSAhIWNvbmZpZy51c2VHcmFkaWVudE9wYWNpdHk7XG4gICAgfSxcbiAgICBfZHJhd0FscGhhOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgbWluID0gdGhpcy5fbWluID0gZGF0YS5taW47XG4gICAgICB2YXIgbWF4ID0gdGhpcy5fbWF4ID0gZGF0YS5tYXg7XG4gICAgICB2YXIgZGF0YSA9IGRhdGEuZGF0YSB8fCBbXTtcbiAgICAgIHZhciBkYXRhTGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAvLyBvbiBhIHBvaW50IGJhc2lzP1xuICAgICAgdmFyIGJsdXIgPSAxIC0gdGhpcy5fYmx1cjtcblxuICAgICAgd2hpbGUoZGF0YUxlbi0tKSB7XG5cbiAgICAgICAgdmFyIHBvaW50ID0gZGF0YVtkYXRhTGVuXTtcblxuICAgICAgICB2YXIgeCA9IHBvaW50Lng7XG4gICAgICAgIHZhciB5ID0gcG9pbnQueTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHBvaW50LnJhZGl1cztcbiAgICAgICAgLy8gaWYgdmFsdWUgaXMgYmlnZ2VyIHRoYW4gbWF4XG4gICAgICAgIC8vIHVzZSBtYXggYXMgdmFsdWVcbiAgICAgICAgdmFyIHZhbHVlID0gTWF0aC5taW4ocG9pbnQudmFsdWUsIG1heCk7XG4gICAgICAgIHZhciByZWN0WCA9IHggLSByYWRpdXM7XG4gICAgICAgIHZhciByZWN0WSA9IHkgLSByYWRpdXM7XG4gICAgICAgIHZhciBzaGFkb3dDdHggPSB0aGlzLnNoYWRvd0N0eDtcblxuXG5cblxuICAgICAgICB2YXIgdHBsO1xuICAgICAgICBpZiAoIXRoaXMuX3RlbXBsYXRlc1tyYWRpdXNdKSB7XG4gICAgICAgICAgdGhpcy5fdGVtcGxhdGVzW3JhZGl1c10gPSB0cGwgPSBfZ2V0UG9pbnRUZW1wbGF0ZShyYWRpdXMsIGJsdXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRwbCA9IHRoaXMuX3RlbXBsYXRlc1tyYWRpdXNdO1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhbHVlIGZyb20gbWluaW11bSAvIHZhbHVlIHJhbmdlXG4gICAgICAgIC8vID0+IFswLCAxXVxuICAgICAgICB2YXIgdGVtcGxhdGVBbHBoYSA9ICh2YWx1ZS1taW4pLyhtYXgtbWluKTtcbiAgICAgICAgLy8gdGhpcyBmaXhlcyAjMTc2OiBzbWFsbCB2YWx1ZXMgYXJlIG5vdCB2aXNpYmxlIGJlY2F1c2UgZ2xvYmFsQWxwaGEgPCAuMDEgY2Fubm90IGJlIHJlYWQgZnJvbSBpbWFnZURhdGFcbiAgICAgICAgc2hhZG93Q3R4Lmdsb2JhbEFscGhhID0gdGVtcGxhdGVBbHBoYSA8IC4wMSA/IC4wMSA6IHRlbXBsYXRlQWxwaGE7XG5cbiAgICAgICAgc2hhZG93Q3R4LmRyYXdJbWFnZSh0cGwsIHJlY3RYLCByZWN0WSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHJlbmRlckJvdW5kYXJpZXNcbiAgICAgICAgaWYgKHJlY3RYIDwgdGhpcy5fcmVuZGVyQm91bmRhcmllc1swXSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQm91bmRhcmllc1swXSA9IHJlY3RYO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVjdFkgPCB0aGlzLl9yZW5kZXJCb3VuZGFyaWVzWzFdKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJCb3VuZGFyaWVzWzFdID0gcmVjdFk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZWN0WCArIDIqcmFkaXVzID4gdGhpcy5fcmVuZGVyQm91bmRhcmllc1syXSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQm91bmRhcmllc1syXSA9IHJlY3RYICsgMipyYWRpdXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZWN0WSArIDIqcmFkaXVzID4gdGhpcy5fcmVuZGVyQm91bmRhcmllc1szXSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyQm91bmRhcmllc1szXSA9IHJlY3RZICsgMipyYWRpdXM7XG4gICAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSxcbiAgICBfY29sb3JpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB0aGlzLl9yZW5kZXJCb3VuZGFyaWVzWzBdO1xuICAgICAgdmFyIHkgPSB0aGlzLl9yZW5kZXJCb3VuZGFyaWVzWzFdO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5fcmVuZGVyQm91bmRhcmllc1syXSAtIHg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fcmVuZGVyQm91bmRhcmllc1szXSAtIHk7XG4gICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgIHZhciBtYXhIZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XG4gICAgICB2YXIgb3BhY2l0eSA9IHRoaXMuX29wYWNpdHk7XG4gICAgICB2YXIgbWF4T3BhY2l0eSA9IHRoaXMuX21heE9wYWNpdHk7XG4gICAgICB2YXIgbWluT3BhY2l0eSA9IHRoaXMuX21pbk9wYWNpdHk7XG4gICAgICB2YXIgdXNlR3JhZGllbnRPcGFjaXR5ID0gdGhpcy5fdXNlR3JhZGllbnRPcGFjaXR5O1xuXG4gICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgeCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgeSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoeCArIHdpZHRoID4gbWF4V2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSBtYXhXaWR0aCAtIHg7XG4gICAgICB9XG4gICAgICBpZiAoeSArIGhlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgICBoZWlnaHQgPSBtYXhIZWlnaHQgLSB5O1xuICAgICAgfVxuXG4gICAgICB2YXIgaW1nID0gdGhpcy5zaGFkb3dDdHguZ2V0SW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdmFyIGltZ0RhdGEgPSBpbWcuZGF0YTtcbiAgICAgIHZhciBsZW4gPSBpbWdEYXRhLmxlbmd0aDtcbiAgICAgIHZhciBwYWxldHRlID0gdGhpcy5fcGFsZXR0ZTtcblxuXG4gICAgICBmb3IgKHZhciBpID0gMzsgaSA8IGxlbjsgaSs9IDQpIHtcbiAgICAgICAgdmFyIGFscGhhID0gaW1nRGF0YVtpXTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGFscGhhICogNDtcblxuXG4gICAgICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmluYWxBbHBoYTtcbiAgICAgICAgaWYgKG9wYWNpdHkgPiAwKSB7XG4gICAgICAgICAgZmluYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFscGhhIDwgbWF4T3BhY2l0eSkge1xuICAgICAgICAgICAgaWYgKGFscGhhIDwgbWluT3BhY2l0eSkge1xuICAgICAgICAgICAgICBmaW5hbEFscGhhID0gbWluT3BhY2l0eTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpbmFsQWxwaGEgPSBhbHBoYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmluYWxBbHBoYSA9IG1heE9wYWNpdHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaW1nRGF0YVtpLTNdID0gcGFsZXR0ZVtvZmZzZXRdO1xuICAgICAgICBpbWdEYXRhW2ktMl0gPSBwYWxldHRlW29mZnNldCArIDFdO1xuICAgICAgICBpbWdEYXRhW2ktMV0gPSBwYWxldHRlW29mZnNldCArIDJdO1xuICAgICAgICBpbWdEYXRhW2ldID0gdXNlR3JhZGllbnRPcGFjaXR5ID8gcGFsZXR0ZVtvZmZzZXQgKyAzXSA6IGZpbmFsQWxwaGE7XG5cbiAgICAgIH1cblxuICAgICAgaW1nLmRhdGEgPSBpbWdEYXRhO1xuICAgICAgdGhpcy5jdHgucHV0SW1hZ2VEYXRhKGltZywgeCwgeSk7XG5cbiAgICAgIHRoaXMuX3JlbmRlckJvdW5kYXJpZXMgPSBbMTAwMCwgMTAwMCwgMCwgMF07XG5cbiAgICB9LFxuICAgIGdldFZhbHVlQXQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICB2YXIgc2hhZG93Q3R4ID0gdGhpcy5zaGFkb3dDdHg7XG4gICAgICB2YXIgaW1nID0gc2hhZG93Q3R4LmdldEltYWdlRGF0YShwb2ludC54LCBwb2ludC55LCAxLCAxKTtcbiAgICAgIHZhciBkYXRhID0gaW1nLmRhdGFbM107XG4gICAgICB2YXIgbWF4ID0gdGhpcy5fbWF4O1xuICAgICAgdmFyIG1pbiA9IHRoaXMuX21pbjtcblxuICAgICAgdmFsdWUgPSAoTWF0aC5hYnMobWF4LW1pbikgKiAoZGF0YS8yNTUpKSA+PiAwO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBnZXREYXRhVVJMOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9XG4gIH07XG5cblxuICByZXR1cm4gQ2FudmFzMmRSZW5kZXJlcjtcbn0pKCk7XG5cblxudmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uIFJlbmRlcmVyQ2xvc3VyZSgpIHtcblxuICB2YXIgcmVuZGVyZXJGbiA9IGZhbHNlO1xuXG4gIGlmIChIZWF0bWFwQ29uZmlnWydkZWZhdWx0UmVuZGVyZXInXSA9PT0gJ2NhbnZhczJkJykge1xuICAgIHJlbmRlcmVyRm4gPSBDYW52YXMyZFJlbmRlcmVyO1xuICB9XG5cbiAgcmV0dXJuIHJlbmRlcmVyRm47XG59KSgpO1xuXG5cbnZhciBVdGlsID0ge1xuICBtZXJnZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1lcmdlZCA9IHt9O1xuICAgIHZhciBhcmdzTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3NMZW47IGkrKykge1xuICAgICAgdmFyIG9iaiA9IGFyZ3VtZW50c1tpXVxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBtZXJnZWRba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG59O1xuLy8gSGVhdG1hcCBDb25zdHJ1Y3RvclxudmFyIEhlYXRtYXAgPSAoZnVuY3Rpb24gSGVhdG1hcENsb3N1cmUoKSB7XG5cbiAgdmFyIENvb3JkaW5hdG9yID0gKGZ1bmN0aW9uIENvb3JkaW5hdG9yQ2xvc3VyZSgpIHtcblxuICAgIGZ1bmN0aW9uIENvb3JkaW5hdG9yKCkge1xuICAgICAgdGhpcy5jU3RvcmUgPSB7fTtcbiAgICB9O1xuXG4gICAgQ29vcmRpbmF0b3IucHJvdG90eXBlID0ge1xuICAgICAgb246IGZ1bmN0aW9uKGV2dE5hbWUsIGNhbGxiYWNrLCBzY29wZSkge1xuICAgICAgICB2YXIgY1N0b3JlID0gdGhpcy5jU3RvcmU7XG5cbiAgICAgICAgaWYgKCFjU3RvcmVbZXZ0TmFtZV0pIHtcbiAgICAgICAgICBjU3RvcmVbZXZ0TmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjU3RvcmVbZXZ0TmFtZV0ucHVzaCgoZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc2NvcGUsIGRhdGEpO1xuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgZW1pdDogZnVuY3Rpb24oZXZ0TmFtZSwgZGF0YSkge1xuICAgICAgICB2YXIgY1N0b3JlID0gdGhpcy5jU3RvcmU7XG4gICAgICAgIGlmIChjU3RvcmVbZXZ0TmFtZV0pIHtcbiAgICAgICAgICB2YXIgbGVuID0gY1N0b3JlW2V2dE5hbWVdLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8bGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGNTdG9yZVtldnROYW1lXVtpXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gQ29vcmRpbmF0b3I7XG4gIH0pKCk7XG5cblxuICB2YXIgX2Nvbm5lY3QgPSBmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciByZW5kZXJlciA9IHNjb3BlLl9yZW5kZXJlcjtcbiAgICB2YXIgY29vcmRpbmF0b3IgPSBzY29wZS5fY29vcmRpbmF0b3I7XG4gICAgdmFyIHN0b3JlID0gc2NvcGUuX3N0b3JlO1xuXG4gICAgY29vcmRpbmF0b3Iub24oJ3JlbmRlcnBhcnRpYWwnLCByZW5kZXJlci5yZW5kZXJQYXJ0aWFsLCByZW5kZXJlcik7XG4gICAgY29vcmRpbmF0b3Iub24oJ3JlbmRlcmFsbCcsIHJlbmRlcmVyLnJlbmRlckFsbCwgcmVuZGVyZXIpO1xuICAgIGNvb3JkaW5hdG9yLm9uKCdleHRyZW1hY2hhbmdlJywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgc2NvcGUuX2NvbmZpZy5vbkV4dHJlbWFDaGFuZ2UgJiZcbiAgICAgIHNjb3BlLl9jb25maWcub25FeHRyZW1hQ2hhbmdlKHtcbiAgICAgICAgbWluOiBkYXRhLm1pbixcbiAgICAgICAgbWF4OiBkYXRhLm1heCxcbiAgICAgICAgZ3JhZGllbnQ6IHNjb3BlLl9jb25maWdbJ2dyYWRpZW50J10gfHwgc2NvcGUuX2NvbmZpZ1snZGVmYXVsdEdyYWRpZW50J11cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHN0b3JlLnNldENvb3JkaW5hdG9yKGNvb3JkaW5hdG9yKTtcbiAgfTtcblxuXG4gIGZ1bmN0aW9uIEhlYXRtYXAoKSB7XG4gICAgdmFyIGNvbmZpZyA9IHRoaXMuX2NvbmZpZyA9IFV0aWwubWVyZ2UoSGVhdG1hcENvbmZpZywgYXJndW1lbnRzWzBdIHx8IHt9KTtcbiAgICB0aGlzLl9jb29yZGluYXRvciA9IG5ldyBDb29yZGluYXRvcigpO1xuICAgIGlmIChjb25maWdbJ3BsdWdpbiddKSB7XG4gICAgICB2YXIgcGx1Z2luVG9Mb2FkID0gY29uZmlnWydwbHVnaW4nXTtcbiAgICAgIGlmICghSGVhdG1hcENvbmZpZy5wbHVnaW5zW3BsdWdpblRvTG9hZF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbHVnaW4gXFwnJysgcGx1Z2luVG9Mb2FkICsgJ1xcJyBub3QgZm91bmQuIE1heWJlIGl0IHdhcyBub3QgcmVnaXN0ZXJlZC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwbHVnaW4gPSBIZWF0bWFwQ29uZmlnLnBsdWdpbnNbcGx1Z2luVG9Mb2FkXTtcbiAgICAgICAgLy8gc2V0IHBsdWdpbiByZW5kZXJlciBhbmQgc3RvcmVcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgcGx1Z2luLnJlbmRlcmVyKGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX3N0b3JlID0gbmV3IHBsdWdpbi5zdG9yZShjb25maWcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBSZW5kZXJlcihjb25maWcpO1xuICAgICAgdGhpcy5fc3RvcmUgPSBuZXcgU3RvcmUoY29uZmlnKTtcbiAgICB9XG4gICAgX2Nvbm5lY3QodGhpcyk7XG4gIH07XG5cbiAgLy8gQFRPRE86XG4gIC8vIGFkZCBBUEkgZG9jdW1lbnRhdGlvblxuICBIZWF0bWFwLnByb3RvdHlwZSA9IHtcbiAgICBhZGREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3N0b3JlLmFkZERhdGEuYXBwbHkodGhpcy5fc3RvcmUsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc3RvcmUucmVtb3ZlRGF0YSAmJiB0aGlzLl9zdG9yZS5yZW1vdmVEYXRhLmFwcGx5KHRoaXMuX3N0b3JlLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3N0b3JlLnNldERhdGEuYXBwbHkodGhpcy5fc3RvcmUsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHNldERhdGFNYXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fc3RvcmUuc2V0RGF0YU1heC5hcHBseSh0aGlzLl9zdG9yZSwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0RGF0YU1pbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9zdG9yZS5zZXREYXRhTWluLmFwcGx5KHRoaXMuX3N0b3JlLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBjb25maWd1cmU6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdGhpcy5fY29uZmlnID0gVXRpbC5tZXJnZSh0aGlzLl9jb25maWcsIGNvbmZpZyk7XG4gICAgICB0aGlzLl9yZW5kZXJlci51cGRhdGVDb25maWcodGhpcy5fY29uZmlnKTtcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdG9yLmVtaXQoJ3JlbmRlcmFsbCcsIHRoaXMuX3N0b3JlLl9nZXRJbnRlcm5hbERhdGEoKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlcGFpbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY29vcmRpbmF0b3IuZW1pdCgncmVuZGVyYWxsJywgdGhpcy5fc3RvcmUuX2dldEludGVybmFsRGF0YSgpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RvcmUuZ2V0RGF0YSgpO1xuICAgIH0sXG4gICAgZ2V0RGF0YVVSTDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZ2V0RGF0YVVSTCgpO1xuICAgIH0sXG4gICAgZ2V0VmFsdWVBdDogZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgICAgaWYgKHRoaXMuX3N0b3JlLmdldFZhbHVlQXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldFZhbHVlQXQocG9pbnQpO1xuICAgICAgfSBlbHNlICBpZiAodGhpcy5fcmVuZGVyZXIuZ2V0VmFsdWVBdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXIuZ2V0VmFsdWVBdChwb2ludCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEhlYXRtYXA7XG5cbn0pKCk7XG5cblxuLy8gY29yZVxudmFyIGhlYXRtYXBGYWN0b3J5ID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgSGVhdG1hcChjb25maWcpO1xuICB9LFxuICByZWdpc3RlcjogZnVuY3Rpb24ocGx1Z2luS2V5LCBwbHVnaW4pIHtcbiAgICBIZWF0bWFwQ29uZmlnLnBsdWdpbnNbcGx1Z2luS2V5XSA9IHBsdWdpbjtcbiAgfVxufTtcblxucmV0dXJuIGhlYXRtYXBGYWN0b3J5O1xuXG5cbn0pOyIsIi8vIGltcG9ydCBoZWF0bWFwQ29udHJvbCBmcm9tIFwiLi9oZWF0bWFwQ29udHJvbFwiXHJcbi8vIHZhciBoZWF0bWFwanMgPSByZXF1aXJlKFwiLi4vbGliL25vZGVfbW9kdWxlcy9oZWF0bWFwanMvaGVhdG1hcC5taW4uanNcIik7XHJcbmltcG9ydCBoZWF0bWFwIGZyb20gXCIuLi9saWIvbm9kZV9tb2R1bGVzL2hlYXRtYXAuanMvYnVpbGQvaGVhdG1hcC5qc1wiXHJcblxyXG5jb25zdCBtYXBDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnRhaW5lclwiKVxyXG5sZXQgdmFyV2lkdGggPSBtYXBDb250YWluZXIub2Zmc2V0V2lkdGhcclxubGV0IHZhckhlaWdodCA9IG1hcENvbnRhaW5lci5vZmZzZXRIZWlnaHRcclxuXHJcbnZhciBjb25maWcgPSB7XHJcbiAgY29udGFpbmVyOiBtYXBDb250YWluZXIsXHJcbiAgcmFkaXVzOiA4MCxcclxuICBtYXhPcGFjaXR5OiAuNSxcclxuICBtaW5PcGFjaXR5OiAwLFxyXG4gIGJsdXI6IC43NSxcclxuICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSgyMDYsMjMxLDI1NSwuOTUpXCJcclxufTtcclxuLy8gY3JlYXRlIGhlYXRtYXAgd2l0aCBjb25maWd1cmF0aW9uXHJcbmxldCBoZWF0bWFwSW5zdGFuY2U7XHJcblxyXG5jb25zb2xlLmxvZyhoZWF0bWFwKVxyXG5cclxuZnVuY3Rpb24gYnVpbGRIZWF0bWFwKCkge1xyXG5cclxuICBoZWF0bWFwSW5zdGFuY2UgPSBoZWF0bWFwLmNyZWF0ZShjb25maWcpO1xyXG4gIGNvbnNvbGUubG9nKGhlYXRtYXBJbnN0YW5jZSlcclxuXHJcbiAgdmFyIGRhdGFQb2ludHMgPSBbXTtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IDEwMDsgaSsrKSB7XHJcbiAgICBsZXQgeF8gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB2YXJXaWR0aCk7XHJcbiAgICBsZXQgeV8gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB2YXJIZWlnaHQpO1xyXG4gICAgbGV0IHZhbHVlXyA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMCk7XHJcblxyXG4gICAgbGV0IG9iaiA9IHsgeDogeF8sIHk6IHlfLCB2YWx1ZTogdmFsdWVfIH1cclxuXHJcbiAgICBpZiAoeF8gPT09IDAgfHwgeV8gPT09IDAgfHwgdmFsdWVfID09PSAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiWkVST1wiLCB4XywgeV8sIHZhbHVlXylcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb25zb2xlLmxvZyhvYmoueCwgb2JqLnksIG9iai52YWx1ZSlcclxuICAgIGRhdGFQb2ludHMucHVzaChvYmopXHJcbiAgfVxyXG5cclxuICBjb25zdCBkYXRhID0ge1xyXG4gICAgbWF4OiAxMDAsXHJcbiAgICBtaW46IDAsXHJcbiAgICBkYXRhOiBkYXRhUG9pbnRzXHJcbiAgfVxyXG5cclxuICBoZWF0bWFwSW5zdGFuY2Uuc2V0RGF0YShkYXRhKTtcclxufVxyXG5cclxuYnVpbGRIZWF0bWFwKClcclxuXHJcbi8vIGRldGVybWluZSBjb250YWluZXIgZGltZW5zaW9ucyBhdCBhIGNlcnRhaW4gaW50ZXJ2YWwuXHJcbi8vIGlmXHJcbmZ1bmN0aW9uIGdldEFjdGl2ZU9mZnNldHMoKSB7XHJcbiAgY29uc3QgY2FwdHVyZVdpZHRoID0gbWFwQ29udGFpbmVyLm9mZnNldFdpZHRoXHJcbiAgLy8gY29uc3QgY2FwdHVyZUhlaWdodCA9IG1hcENvbnRhaW5lci5vZmZzZXRIZWlnaHRcclxuICAvL2V2YWx1YXRlIGNvbnRhaW5lciB3aWR0aCBhZnRlciAwLjUgc2Vjb25kcyB2cyBpbml0aWFsIGNvbnRhaW5lciB3aWR0aFxyXG4gIGlmIChjYXB0dXJlV2lkdGggPT09IHZhcldpZHRoKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcInVuY2hhbmdlZFwiKVxyXG4gIH0gZWxzZSB7XHJcbiAgICB2YXJXaWR0aCA9IGNhcHR1cmVXaWR0aFxyXG4gICAgY29uc29sZS5sb2coXCJuZXcgd2lkdGhcIiwgdmFyV2lkdGgpXHJcbiAgICAvL2NsZWFyIGhlYXRtYXBcclxuICAgIG1hcENvbnRhaW5lci5yZW1vdmVDaGlsZChtYXBDb250YWluZXIuY2hpbGROb2Rlc1swXSlcclxuICAgIC8vYnVpbGQgaGVhdG1hcCBhZ2FpblxyXG4gICAgYnVpbGRIZWF0bWFwKClcclxuICB9XHJcbn1cclxuXHJcbnNldEludGVydmFsKGdldEFjdGl2ZU9mZnNldHMsIDUwMClcclxuIl19
